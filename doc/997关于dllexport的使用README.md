# 关于dllexport的使用

## 关于动态库和静态库

动态库和静态库都是在软件开发中用于组织和共享代码的重要工具。它们在编译、链接和运行阶段的行为有所不同，下面我将简要解释它们的区别和用途。

1. 静态库：
- 编译时链接：静态库在编译时会被完全复制到生成的可执行文件中。这意味着可执行文件包含了库的所有代码，因此它在运行时不依赖于外部库文件。
- 文件大小：生成的可执行文件通常比较大，因为它包含了所有需要的代码。
- 独立性：静态库使得可执行文件更独立，不需要在目标系统上安装额外的库文件。

2. 动态库：
- 运行时链接：动态库在编译时并不会被复制到可执行文件中，而是在运行时加载。可执行文件只包含了对动态库的引用，而不包含实际的库代码。
- 文件大小：生成的可执行文件通常较小，因为它不包含库的代码，但需要系统上已经安装了相应的动态库文件。
- 共享性：多个可执行文件可以共享同一个动态库，这可以节省磁盘空间并减少内存占用。


下面是一些关于动态库和静态库的常见用途和注意事项：

静态库的用途：
- 当你希望将代码嵌入到可执行文件中，以确保在不同环境中运行时不会有依赖问题时，使用静态库是一个好选择。
- 静态库适用于小型项目或者在特定环境下运行的应用程序。

动态库的用途：
- 当你希望多个程序共享同一个库的代码，以减少磁盘空间和内存占用时，使用动态库是一个好选择。
- 动态库适用于大型项目，因为多个应用程序可以共享同一个库，从而减少了重复的代码加载。

需要注意的是，不同操作系统和编程语言可能对动态库和静态库的实现和使用有一些差异。在选择使用哪种库时，需要考虑项目的需求、性能和可维护性等因素。


## Windows平台下项目链接动态库模块编译时报错：error LNK2019: 无法解析的外部符号

制作一个第三方动态库时，通常会包含以下步骤：
- 编译和链接：动态库的制作者会使用编译器将源代码编译成动态链接库，并将其链接到所需的依赖库（如果有的话）。
- 导出符号：制作者会使用适当的方式来标记和导出动态库中的函数和变量，以确保它们在动态库中可见并可以被外部程序使用。
- 提供头文件：通常，制作者还会提供与动态库一起使用的头文件，这些头文件包含了函数和变量的声明，以便你的代码可以正确调用动态库中的函数。
- 打包和分发：制作者将编译好的动态库、头文件和其他必要文件打包到安装包中，以供用户安装。

所以无法解析的外部符号一般都是动态库没有导出符号

## 动态库如何导出符号
eg:
1. 添加头文件
    ```
    #pragma once
    #include <QtWidgets>
    #include <QtCore>

    //__declspec 在 #include <QtCore/qglobal.h> 中

    #ifdef WIN32

    #ifdef AWIDGET_LIB
    #define AWIDGET_EXPORT __declspec(dllexport)
    #else
    #define AWIDGET_EXPORT __declspec(dllimport)
    #endif

    #else

    #define AWIDGET_EXPORT

    #endif
    ```
2. 在CmakeList.txt中添加宏定义
    ```
    add_definitions(
        -DAWIDGET_LIB
    )
    ```

## 使用静态库不需要导出符号
静态库和动态库之间有一些重要的区别，其中之一就是导出符号的需求。

在静态库中，不需要导出符号。这是因为静态库在编译时已经被链接到可执行文件中，所有的符号（函数和变量）都会被静态库的代码直接合并到可执行文件中。因此，编译器和链接器在编译时就能够访问并识别静态库中的所有符号，不需要额外的导出和导入过程。

对于动态库，情况不同。动态库是在运行时加载的，因此需要一种机制来告诉操作系统和其他程序如何在运行时访问和使用动态库中的函数和变量。这就是为什么在动态库中使用 dllexport 或其他类似的机制来标记和导出符号的原因。这些导出符号的信息允许外部程序在运行时定位和使用动态库中的函数和变量。

- 在静态库中，不需要导出符号，因为静态库的代码在编译时就被合并到可执行文件中。
- 在动态库中，需要导出符号，以便在运行时动态加载并使用库中的函数和变量。

## 那什么情况下使用静态库不使用动态库呢
使用静态库和动态库的选择取决于项目的需求和目标，每种库都有其适用的情况。以下是一些情况，其中使用静态库可能更合适：

- 独立应用程序：如果你正在构建一个独立的应用程序，而不需要与其他应用程序共享代码，静态库可能是一个不错的选择。静态库的代码会在编译时完全合并到可执行文件中，使得应用程序更独立，没有外部依赖。
- 控制版本：静态库允许你更好地控制你的应用程序的依赖关系。因为静态库的代码被包含在可执行文件中，你不需要担心不同版本的动态库之间的兼容性问题。
- 性能优化：静态库在性能方面可能更有优势，因为它不需要在运行时加载和链接，而是在编译时完成链接。这可以减少启动时间和执行速度。
- 简化部署：使用静态库可以简化应用程序的部署过程，因为你不需要在目标系统上安装额外的动态库文件。
- 可移植性：静态库可以提高应用程序的可移植性，因为它不依赖于目标系统上的特定库版本。你可以将所有必要的库代码打包到你的应用程序中。

然而，需要注意的是，静态库也有一些劣势，比如占用更多的磁盘空间，不支持动态更新和共享，以及在多个应用程序之间共享代码时可能引发一些问题。因此，在某些情况下，使用动态库可能更合适，特别是当你希望多个应用程序共享相同的库代码时，或者希望更灵活地更新库的版本。

## 为什么mac不需要对动态库进行符号导出
在 macOS 上，通常使用的动态库格式是 macOS Framework 或者动态共享库（.dylib），与 Windows 上的动态链接库（.dll）有所不同。在 macOS 上，动态库的导出和导入机制不需要像 Windows 中的 dllexport 和 dllimport 那样显式定义，因为 macOS 动态库的默认行为是导出所有公共符号。

macOS 的动态库默认导出了库中的所有公共符号，这使得其他应用程序可以直接使用这些符号，而不需要额外的声明。这与 Windows 上的显式导出和导入机制不同。在 Windows 上，你需要使用 dllexport 来显式告诉编译器和链接器哪些符号应该被导出，而在客户端应用程序中，你需要使用 dllimport 来告诉编译器哪些符号应该被导入。

在 macOS 上，如果你想将某些符号隐藏，可以使用 __attribute__((visibility("hidden"))) 来标记这些符号，以便防止它们被导出到动态库的符号表中。但这通常是不必要的，除非你有明确的理由需要隐藏某些符号。

总之，macOS 上的动态库默认导出所有公共符号，这使得在编写和使用动态库时更加方便，而不需要显式地使用 dllexport 和 dllimport。但要记住，不同平台上的动态库行为可能会有所不同，你需要根据目标平台的规范来进行开发。


## 动态库需要复制到可执行目录下才能启动
动态库工程编译后生成文件后需要复制到启动项目可执行目录下才能启动，静态库不需要。